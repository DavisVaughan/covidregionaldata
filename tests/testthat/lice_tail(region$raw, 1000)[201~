slice                  package:dplyr                   R Documentation

_S_u_b_s_e_t _r_o_w_s _u_s_i_n_g _t_h_e_i_r _p_o_s_i_t_i_o_n_s

_D_e_s_c_r_i_p_t_i_o_n:

     ‘slice()’ lets you index rows by their (integer) locations. It
     allows you to select, remove, and duplicate rows. It is
     accompanied by a number of helpers for common use cases:

        • ‘slice_head()’ and ‘slice_tail()’ select the first or last
          rows.

        • ‘slice_sample()’ randomly selects rows.

        • ‘slice_min()’ and ‘slice_max()’ select rows with highest or
          lowest values of a variable.

     If ‘.data’ is a grouped_df, the operation will be performed on
     each group, so that (e.g.) ‘slice_head(df, n = 5)’ will select the
     first five rows in each group.

_U_s_a_g_e:

     slice(.data, ..., .preserve = FALSE)
     
     slice_head(.data, ..., n, prop)
     
     slice_tail(.data, ..., n, prop)
     
     slice_min(.data, order_by, ..., n, prop, with_ties = TRUE)
     
     slice_max(.data, order_by, ..., n, prop, with_ties = TRUE)
     
     slice_sample(.data, ..., n, prop, weight_by = NULL, replace = FALSE)
     
_A_r_g_u_m_e_n_t_s:

   .data: A data frame, data frame extension (e.g. a tibble), or a lazy
          data frame (e.g. from dbplyr or dtplyr). See _Methods_,
          below, for more details.

     ...: For ‘slice()’: <‘data-masking’> Integer row values.

          Provide either positive values to keep, or negative values to
          drop. The values provided must be either all positive or all
          negative. Indices beyond the number of rows in the input are
          silently ignored.

          For ‘slice_helpers()’, these arguments are passed on to
          methods.

.preserve: Relevant when the ‘.data’ input is grouped. If ‘.preserve =
          FALSE’ (the default), the grouping structure is recalculated
          based on the resulting data, otherwise the grouping is kept
          as is.

 n, prop: Provide either ‘n’, the number of rows, or ‘prop’, the
          proportion of rows to select. If neither are supplied, ‘n =
          1’ will be used.

          If ‘n’ is greater than the number of rows in the group (or
          ‘prop > 1’), the result will be silently truncated to the
          group size. If the ‘prop’ortion of a group size is not an
          integer, it is rounded down.

order_by: Variable or function of variables to order by.

with_ties: Should ties be kept together? The default, ‘TRUE’, may
          return more rows than you request. Use ‘FALSE’ to ignore
          ties, and return the first ‘n’ rows.

weight_by: Sampling weights. This must evaluate to a vector of
          non-negative numbers the same length as the input. Weights
          are automatically standardised to sum to 1.

 replace: Should sampling be performed with (‘TRUE’) or without
          (‘FALSE’, the default) replacement.

_D_e_t_a_i_l_s:

     Slice does not work with relational databases because they have no
     intrinsic notion of row order. If you want to perform the
     equivalent operation, use ‘filter()’ and ‘row_number()’.

_V_a_l_u_e:

     An object of the same type as ‘.data’. The output has the
     following properties:

        • Each row may appear 0, 1, or many times in the output.

        • Columns are not modified.

        • Groups are not modified.

        • Data frame attributes are preserved.

_M_e_t_h_o_d_s:

     These function are *generic*s, which means that packages can
     provide implementations (methods) for other classes. See the
     documentation of individual methods for extra arguments and
     differences in behaviour.

     Methods available in currently loaded packages:

        • ‘slice()’: no methods found.

        • ‘slice_head()’: no methods found.

        • ‘slice_tail()’: no methods found.

        • ‘slice_min()’: no methods found.

        • ‘slice_max()’: no methods found.

        • ‘slice_sample()’: no methods found.

_S_e_e _A_l_s_o:

     Other single table verbs: ‘arrange()’, ‘filter()’, ‘mutate()’,
     ‘rename()’, ‘select()’, ‘summarise()’

_E_x_a_m_p_l_e_s:

     mtcars %>% slice(1L)
     # Similar to tail(mtcars, 1):
     mtcars %>% slice(n())
     mtcars %>% slice(5:n())
     # Rows can be dropped with negative indices:
     slice(mtcars, -(1:4))
     
     # First and last rows based on existing order
     mtcars %>% slice_head(n = 5)
     mtcars %>% slice_tail(n = 5)
     
     # Rows with minimum and maximum values of a variable
     mtcars %>% slice_min(mpg, n = 5)
     mtcars %>% slice_max(mpg, n = 5)
     
     # slice_min() and slice_max() may return more rows than requested
     # in the presence of ties. Use with_ties = FALSE to suppress
     mtcars %>% slice_min(cyl, n = 1)
     mtcars %>% slice_min(cyl, n = 1, with_ties = FALSE)
     
     # slice_sample() allows you to random select with or without replacement
     mtcars %>% slice_sample(n = 5)
     mtcars %>% slice_sample(n = 5, replace = TRUE)
     
     # you can optionally weight by a variable - this code weights by the
     # physical weight of the cars, so heavy cars are more likely to get
     # selected
     mtcars %>% slice_sample(weight_by = wt, n = 5)
     
     # Group wise operation ----------------------------------------
     df <- tibble(
       group = rep(c("a", "b", "c"), c(1, 2, 4)),
       x = runif(7)
     )
     
     # All slice helpers operate per group, silently truncating to the group
     # size, so the following code works without error
     df %>% group_by(group) %>% slice_head(n = 2)
     
     # When specifying the proportion of rows to include non-integer sizes
     # are rounded down, so group a gets 0 rows
     df %>% group_by(group) %>% slice_head(prop = 0.5)
     
     # Filter equivalents --------------------------------------------
     # slice() expressions can often be written to use `filter()` and
     # `row_number()`, which can also be translated to SQL. For many databases,
     # you'll need to supply an explicit variable to use to compute the row number.
     filter(mtcars, row_number() == 1L)
     filter(mtcars, row_number() == n())
     filter(mtcars, between(row_number(), 5, n()))
     

